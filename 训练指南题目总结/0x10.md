## 0x10 基本数据结构

### 0x11 栈

### 0x12 队列

#### Team Queue

这道题确实不是很难，运用“整体法”把小组和小组成员“分级调节”即可。

#### 蚯蚓

这是道好题。

用堆的做法挺好想的，但是复杂度不太对。只要上了 $10^6$ 就要考虑不用 $O(n\log n)$ 了（二分这种神仙 $\log$ 除外）。

有一个不显然的规律：在被切下来的两类蚯蚓中，先切下来的一定比后切下来的长。这个的证明值得反复品味：

设蚯蚓 $x,y\ (x\ge y)$ 先后（相隔 $t$ 时间）被切。

$x$ 被切后产生了 $\lfloor px\rfloor$ 和 $x-\lfloor px\rfloor$ 两段，经过 $t$ 时间后变为 $\lfloor px\rfloor+u$ 和 $x+u-\lfloor px\rfloor$ 两段（其中 $u=qt$）。

$y$ 经过时间 $t$ 后变为 $y+u$，又被切为 $\lfloor p(y+u) \rfloor$ 和 $y+u-\lfloor p(y+u) \rfloor$ 两段。

下面证明 $\lfloor px\rfloor+u\ge \lfloor p(y+u) \rfloor$，$x+u-\lfloor px\rfloor\ge y+u-\lfloor p(y+u) \rfloor$。

先证第一个。$\lfloor px \rfloor+u=\lfloor px+u\rfloor\ge \lfloor py+u\rfloor\ge \lfloor py+pu \rfloor$。第一步是因为整数可以放进和拿出取整符号中，最后一步是因为 $0<p<1$。

再证第二个。第二个式子等价于 $x-\lfloor px \rfloor\ge y-\lfloor p(y+u) \rfloor$，把右端放大得到 $x-\lfloor px \rfloor\ge y-\lfloor py \rfloor$，即是 $\lfloor (1-p)x \rfloor\ge \lfloor (1-p)y \rfloor$，确实成立。

于是我们就只需先把蚯蚓排序，再用三个“优先的队列”分别维护原蚯蚓、$p$ 蚯蚓、$1-p$ 蚯蚓的最大值即可。

#### 双端队列

这题也不容易。

按下标顺序思考，发现找不到性质啊啊啊啊啊啊。

这时候变换一下主元（换元法），从数值大小顺序思考，我们就可以发现，在每个双端队列中，“下标数组”（即数值的相对大小到下标的映射）一定是下凸的（先减后增）。

然后还有比较神仙的“相等的数照顾一下”策略。再下来就是贪心的分段了。

#### 最大子序和

其实单调队列优化 dp 的特征还比较明显。这里就是一个明显的例子——前驱状态会过期。

### 0x13 链表与邻接表

链表真的是很神仙的数据结构。但是网上似乎鲜有它的应用。

#### 邻值查找

对每个数求前缀中的前驱 / 后继，当然想到平衡树！

其实如果可以离线，也可以用链表。

先把所有数排序，组成链表。接着从右往左不断地把数从链表中删除，这样就构成了“前缀”。在删除前看一下左右两边，就得到前缀中的前驱和后继。

#### Running Median

求中位数……

涉及到前缀以及“序”，可以考虑离线下来用链表。

先把所有数排序，组成链表，在逐步删数的过程中维护中位数指针即可。

### 0x14 Hana! ~ Hash

#### Snowflake Snow Snowflakes

环串同构？做过[项链](https://www.luogu.org/problem/T68689)一题的你一定知道怎么做！

不想一一比较？请花希酱来帮忙！

只比较 hash 值相同的串是否同构即可。

但是注意，一定不要直接判定“hash 值相同的串就相同”！这是“两两判断”，很容易出现哈希碰撞的；当然用双哈希也许就可以直接判断？

#### 兔子与兔子

子串哈希接近模板的题目。

#### Palindrome

这道题演示了哈希的灵活之处。很多字符串题用哈希 + 二分是可以完成的！

当然 Manacher 也不错，只要了解思想，应该是不太难推的。

#### 后缀数组

哈希法后缀排序是“加快两个后缀的比较过程”。二分“两个后缀走向不同的位置”，直接比较这个位置即可，仅比倍增法多一个 $\log$。

另外，快去背倍增后缀排序！

### 0x15 字符串

#### Period

回去看[KMP(MP)小记](https://www.luogu.org/blog/Sweetlemon/kmp-note)吧，挺详细的。另外，书中对 KMP 的描述使用了一个 f 数组，也许是为了与求 next 数组接轨，也许是为了和扩展 KMP 接轨。另外，OI Wiki 对 [KMP](https://oi-wiki.org/string/kmp/) 和 [扩展 KMP](https://oi-wiki.org/string/z-func/) 都有详细的介绍。

#### 最小表示法

如果是背记算法的话，记住“如果不等就直接跳过去”，“指针单调右移”就好了。

如果要理解算法的话，考虑 $s[l_1...r_1],s[l_2...r_2]$，其中 $s[l_1...r_1-1]=s[l_2...r_2-1],s[r_1]<s[r_2]$。下面证明，对于任意 $s[l_2+\Delta...](l_2\le l_2+\Delta \le r_2)$ 都不是最小表示。

怎么证明呢？我们构造！

根据唯一的条件（“相等”），我们找到了与 $s[l_2+\Delta...]$ 的前段相等的 $s[l_1+\Delta...]$。这两个环串在前面完全相同，但是在失配点 $s[l_2+\Delta...]$ 会更大——于是它不是最小表示法！

于是证明完毕，可以跳过去。另外注意两指针位置相等时，其中一个指针要前移一位。

### 0x16 Trie



### 0x17 二叉堆

### 0x18 总结与练习
