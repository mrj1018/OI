## 0x10 基本数据结构

### 0x11 栈

### 0x12 队列

#### Team Queue

这道题确实不是很难，运用“整体法”把小组和小组成员“分级调节”即可。

#### 蚯蚓

这是道好题。

用堆的做法挺好想的，但是复杂度不太对。只要上了 $10^6$ 就要考虑不用 $O(n\log n)$ 了（二分这种神仙 $\log$ 除外）。

有一个不显然的规律：在被切下来的两类蚯蚓中，先切下来的一定比后切下来的长。这个的证明值得反复品味：

设蚯蚓 $x,y\ (x\ge y)$ 先后（相隔 $t$ 时间）被切。

$x$ 被切后产生了 $\lfloor px\rfloor$ 和 $x-\lfloor px\rfloor$ 两段，经过 $t$ 时间后变为 $\lfloor px\rfloor+u$ 和 $x+u-\lfloor px\rfloor$ 两段（其中 $u=qt$）。

$y$ 经过时间 $t$ 后变为 $y+u$，又被切为 $\lfloor p(y+u) \rfloor$ 和 $y+u-\lfloor p(y+u) \rfloor$ 两段。

下面证明 $\lfloor px\rfloor+u\ge \lfloor p(y+u) \rfloor$，$x+u-\lfloor px\rfloor\ge y+u-\lfloor p(y+u) \rfloor$。

先证第一个。$\lfloor px \rfloor+u=\lfloor px+u\rfloor\ge \lfloor py+u\rfloor\ge \lfloor py+pu \rfloor$。第一步是因为整数可以放进和拿出取整符号中，最后一步是因为 $0<p<1$。

再证第二个。第二个式子等价于 $x-\lfloor px \rfloor\ge y-\lfloor p(y+u) \rfloor$，把右端放大得到 $x-\lfloor px \rfloor\ge y-\lfloor py \rfloor$，即是 $\lfloor (1-p)x \rfloor\ge \lfloor (1-p)y \rfloor$，确实成立。

于是我们就只需先把蚯蚓排序，再用三个“优先的队列”分别维护原蚯蚓、$p$ 蚯蚓、$1-p$ 蚯蚓的最大值即可。

#### 双端队列

这题也不容易。

按下标顺序思考，发现找不到性质啊啊啊啊啊啊。

这时候变换一下主元（换元法），从数值大小顺序思考，我们就可以发现，在每个双端队列中，“下标数组”（即数值的相对大小到下标的映射）一定是下凸的（先减后增）。

然后还有比较神仙的“相等的数照顾一下”策略。再下来就是贪心的分段了。

#### 最大子序和

其实单调队列优化 dp 的特征还比较明显。这里就是一个明显的例子——前驱状态会过期。

### 0x13 链表与邻接表

链表真的是很神仙的数据结构。但是网上似乎鲜有它的应用。

#### 邻值查找

对每个数求前缀中的前驱 / 后继，当然想到平衡树！

其实如果可以离线，也可以用链表。

先把所有数排序，组成链表。接着从右往左不断地把数从链表中删除，这样就构成了“前缀”。在删除前看一下左右两边，就得到前缀中的前驱和后继。

#### Running Median

求中位数……

涉及到前缀以及“序”，可以考虑离线下来用链表。

先把所有数排序，组成链表，在逐步删数的过程中维护中位数指针即可。

### 0x14 Hana! ~ Hash

### 0x15 字符串

### 0x16 Trie

### 0x17 二叉堆

### 0x18 总结与练习
